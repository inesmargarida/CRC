# -*- coding: utf-8 -*-
"""CRC_project_peer_opinion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YXFOhk3ErvN_FVEyeOhnFW1x4sZ91iwo

# Imports
"""

# Commented out IPython magic to ensure Python compatibility.
import networkx as nx
# %matplotlib inline
import numpy as np
import random
import matplotlib
print(nx.__version__)
import matplotlib.pyplot as plt
import math

"""# Exponential Network"""

def exp_graph(n, m, seed):
  random.seed = seed
  G = nx.Graph()
  for i in range(n):
    if i == 0:
      G.add_node(0)
    elif i < m:
        G.add_edge(i,i-1)
    else: # random attachment
      connections = random.sample(range(0, i), m)
      for node in connections:
        G.add_edge(i, node)
  
  return G

"""# Model

"""

seed = 42
max_distance = 5
random.seed = seed

class Model:
  def __init__(self, Z, avg_degree, model_name):
    ''' Model properties '''
    self.avg_degree = avg_degree
    self.Z = Z
    self.model_name = model_name
    
    ''' Create Model '''
    if(model_name == 'BA'):
      self.G = nx.barabasi_albert_graph(self.Z, self.avg_degree, seed = seed)
    elif(model_name == 'Exp'):
      self.G = exp_graph(self.Z, self.avg_degree, seed = seed)
    elif(model_name == 'HoSW'):
      self.G = nx.connected_watts_strogatz_graph(self.Z, self.avg_degree, 0.1, tries= 100, seed = seed)
    elif(model_name == 'HeSW'):
      self.G = nx.connected_watts_strogatz_graph(self.Z, self.avg_degree, 1, tries= 100, seed = seed)
    
    self.G.graph['name']=self.model_name

    self.delta = []
    self.eps = []
    for i in range(max_distance):
      self.delta.append(0)
      self.eps.append(0)

    self.t = 1
    self.j = 1

    self.influenced = set()

  def mark_susceptibles(self):
      for node in list(self.G.nodes()):
          self.G.nodes[node]['influenced'] = 0

  def calculate_propensity(self):
    self.update_average_probabilities()
    self.random_model.update_average_probabilities() 

  def calculate_normalized_propensity(self):
    x = list()
    y = list()
    for i in range(max_distance):
      print('eps ', self.eps[i], ' epsrandom ', self.random_model.eps[i])
      self.delta[i] = (self.eps[i] / self.random_model.eps[i]) - 1
      print('delta_' + str(i+1) + '/ delta_1 = ', self.delta[i] / self.delta[0])
      x.append(self.delta[i] / self.delta[0])  
      y.append(i+1)

    fig = plt.figure()
    ax = fig.add_axes([0,0,1,1])
    plt.ylim(-0.6, 1.1)
    ax.bar(y,x)
    ax.grid()
    plt.xlabel("social distance")
    plt.ylabel("delta_n/delta_1")
    plt.show()

  def neighbors_at_distance(self, source, neighbors_list):
    for i in range(max_distance):
      neighbors_list.append(set())
      neighbors_list[i] = set(nx.bfs_tree(self.G, source, depth_limit=i+1))

    for i in range(max_distance - 1, 1, -1):
      neighbors_list[i] = neighbors_list[i].difference(neighbors_list[i-1])

  def update_average_probabilities(self):
    if(self.j == 0):
      print('fin')
      return

    j_source = []
    count = []
    
    for i in range(max_distance):
      j_source.append(0)
      count.append(0)

    for source in list(self.G.nodes()):
        neighbors_list = []
        self.neighbors_at_distance(source,neighbors_list)

        for i in range(max_distance):
          if len(neighbors_list[i]) > 0:
            neig_j = 0
            for neighbor in neighbors_list[i]:
                if self.G.nodes[neighbor]['influenced'] == self.G.nodes[source]['influenced']:
                    neig_j += 1

            j_source[i] = (j_source[i] * count[i] + neig_j / len(neighbors_list[i])) / (count[i] + 1) 
            count[i] += 1
    
    for i in range(max_distance):
        if(count[i] > 0):
          self.eps[i] = (self.eps[i] * (self.t) + j_source[i]) / (self.t + 1)
   
  def colorMap(self, color_map):
    for node in list(self.G.nodes()):
        if self.G.nodes[node]['influenced'] == 0:
            color_map.append('blue')
        elif self.G.nodes[node]['influenced'] == 1:
            color_map.append('red')

  def draw(self):
      color_map = []  
      self.colorMap(color_map)
      nx.draw(self.G, node_color=color_map, with_labels=False)
      plt.show()



"""# Random Model"""

class RandomModel(Model):
  def __init__(self, Z, avg_degree, model_name):
    super().__init__(Z, avg_degree, model_name)
    self.j = 0
    random.seed = 42
    self.mark_susceptibles()

  def mark_susceptibles(self):
    super().mark_susceptibles()
  
  def neighbors_at_distance(self, source, neighbors_list):
    super().neighbors_at_distance(source, neighbors_list)
  
  def update_average_probabilities(self):
    super().update_average_probabilities()

  def calculate_propensity(self):
    super().calculate_propensity()

  def calculate_normalized_propensity(self):
    super().calculate_normalized_propensity()
    
  def mark_influenced(self, j):
    self.mark_susceptibles()
    self.influenced = set()
    self.j = j
    nodes_random = random.sample(list(self.G.nodes()), j)
    for node in nodes_random:
      self.G.nodes[node]['influenced'] = 1
      self.influenced.add(node)

"""# SIR Model

"""

class SIRModel(Model):
  def __init__(self, Z, avg_degree, model_name):
    super().__init__(Z, avg_degree, model_name)
    np.random.seed = seed

  def mark_susceptibles(self):
      super().mark_susceptibles()

  def simulate_SIR(self, alpha, beta):
      print(self.model_name)
      print('Diameter: ' + str(nx.diameter(self.G)))
      print('Average Degree: {}'.format(self.G.number_of_edges() /self.G.number_of_nodes()))
      print('Average Path Length: {}'.format(nx.average_shortest_path_length(self.G)))
      
      # 1 . All nodes are marked as susceptibles
      self.mark_susceptibles()
      # 2. One node randomly get infected (value:0 = susceptible; value:1 = infected; value:2 = recovered)
      patient_zero_n = random.choice(list(self.G.nodes()))
      self.G.nodes[patient_zero_n]['influenced'] = 1
      #self.draw()
      # 3. Create random model to calculate epsilon of random distribution of infected
      self.create_random_model()
      # 4. Simulate SIR - stops when there is no infected node
      self.SIR_model(alpha, beta, patient_zero_n)
  
  def SIR_model(self, alpha, beta, n0):

      self.influenced.add(n0)

      while len(self.influenced) != 0:
          infected_list = self.influenced.copy()

          for node in infected_list:
              neighbors = list(self.G.neighbors(node))

              for neighbor in neighbors:

                  # Neighbor gets infected with probability alpha
                  if self.G.nodes[neighbor]['influenced'] == 0 and np.random.uniform() < alpha: 
                      self.influenced.add(neighbor)
                      self.G.nodes[neighbor]['influenced'] = 1
                      #self.random_model.mark_infected(1) 
                      self.j += 1

              # Patient recovers with probability beta       
              if np.random.uniform() < beta:           
                  self.G.nodes[node]['influenced'] = 2
                  #self.random_model.mark_recovered(1)
                  self.influenced.remove(node)
                  self.j -= 1

          self.random_model.mark_influenced(self.j)
          self.calculate_propensity()
          #self.draw()
          #change order below
          self.t+=1
          self.random_model.t+=1 

      self.calculate_normalized_propensity()
      return
  
  def calculate_propensity(self):
    super().calculate_propensity()

  def calculate_normalized_propensity(self):
    super().calculate_normalized_propensity()

  def neighbors_at_distance(self, source, neighbors_list):
    super().neighbors_at_distance(source, neighbors_list)

  def update_average_probabilities(self):
    super().update_average_probabilities()
  
  def create_random_model(self):
    self.random_model = RandomModel(self.Z, self.avg_degree, self.model_name)
    self.random_model.mark_influenced(1)  
      
  def colorMap(self, color_map):
      for node in list(self.G.nodes()):
          if self.G.nodes[node]['influenced'] == 0:
              color_map.append('blue')
          elif self.G.nodes[node]['influenced'] == 1:
              color_map.append('red')
          else: 
              color_map.append('green')

"""# Voter Model"""

class VoterModel(Model):
  def __init__(self, Z, avg_degree, model_name):
    super().__init__(Z, avg_degree, model_name)
    self.j = 0

  def simulate_VM(self):
    print('Voter Model / ' + self.model_name)
    print('Diameter: ' + str(nx.diameter(self.G)))
    print('Average Degree: ' + str(self.G.number_of_edges() /self.G.number_of_nodes()))
    print('Average Path Length: {}'.format(nx.average_shortest_path_length(self.G)))

    for i in range(self.Z):
      self.G.nodes[i]['influenced'] = random.choice([0,1])
      if (self.G.nodes[i]['influenced'] == 1):
        self.influenced.add(list(self.G.nodes())[i])
        self.j += 1

    self.create_random_model()
    self.VM()

  def VM(self):
    while(self.t < self.Z and 0 < self.j < self.Z):

      if(self.t % 10 == 0):
        print(str(self.t/self.Z) + '%')
      influenced_copy = self.influenced.copy()

      for node in list(self.G.nodes()):
        neighbor = random.choice(list(self.G.neighbors(node)))
        if(self.G.nodes[neighbor]['influenced'] == 1):
          if(self.G.nodes[node]['influenced'] == 0):
            self.G.nodes[node]['influenced'] = 1
            self.influenced.add(node)
            self.j += 1
        else:
          if(self.G.nodes[node]['influenced'] == 1):
            self.G.nodes[node]['influenced'] = 0
            self.influenced.discard(node)
            self.j -= 1


      self.random_model.mark_influenced(self.j)
      self.calculate_propensity()
      self.t+=1
      self.random_model.t+=1
    self.calculate_normalized_propensity()
    return

  def calculate_propensity(self):
    super().calculate_propensity()

  def calculate_normalized_propensity(self):
    super().calculate_normalized_propensity()

  def neighbors_at_distance(self, source, neighbors_list):
    super().neighbors_at_distance(source, neighbors_list)

  def update_average_probabilities(self):
    super().update_average_probabilities()
  
  def create_random_model(self):
    self.random_model = RandomModel(self.Z, self.avg_degree, self.model_name)
  
  def colorMap(self, color_map):
    super().colorMap(color_map)

"""# Prisoner's Dilemma Model"""

class PDModel(Model):
  def __init__(self, Z, avg_degree, model_name):
    super().__init__(Z, avg_degree, model_name)
    self.j = 0
    np.random.seed = seed

    self.payoff_matrix = [ (1, 1), (-1,2) , 
                           (2,-1), (0, 0) ]

  def simulate_PD(self, beta):
    self.beta = beta

    print('Prisoners Dilemma Model / ' + self.model_name)
    print('Diameter: ' + str(nx.diameter(self.G)))
    print('Average Degree: ' + str(self.G.number_of_edges() /self.G.number_of_nodes()))
    print('Average Path Length: {}'.format(nx.average_shortest_path_length(self.G)))

    for i in range(self.Z):
      self.G.nodes[i]['influenced'] = random.choice([0,1])
      self.G.nodes[i]['fitness'] = 0
      if (self.G.nodes[i]['influenced'] == 1):
        self.influenced.add(list(self.G.nodes())[i])
        self.j += 1

    self.create_random_model()
    self.PD()

  def PD(self):
    while(self.t < self.Z and 0 < self.j < self.Z):

      if(self.t % 10 == 0):
        print(str(self.t*100/self.Z) + '%')
      

      for node in list(self.G.nodes()):
        neighbor = random.choice(list(self.G.neighbors(node)))

        fA = self.G.nodes[node]['fitness']
        fB = self.G.nodes[neighbor]['fitness']
        pA = self.calculate_probability_imitate(fA, fB)
        pB = self.calculate_probability_imitate(fB, fA)
        strategyA = np.random.uniform() < pA # true - cooperate : false - defect
        strategyB = np.random.uniform() < pB

        if(strategyA): # A Strategy - Cooperate
          if(self.G.nodes[neighbor]['influenced'] == 1):
            if(self.G.nodes[node]['influenced'] == 0):
              self.G.nodes[node]['influenced'] = 1
              self.j += 1
          else:
            if(self.G.nodes[node]['influenced'] == 1):
              self.G.nodes[node]['influenced'] = 0
              self.j -= 1
          
          if(strategyB):
            self.G.nodes[node]['fitness'] += self.payoff_matrix[0][0]
            self.G.nodes[node]['fitness'] += self.payoff_matrix[0][1]
          else:
            self.G.nodes[node]['fitness'] += self.payoff_matrix[1][0]
            self.G.nodes[node]['fitness'] += self.payoff_matrix[1][1] 
        
        else: # A Strategy - Defect
          if(strategyB):
            self.G.nodes[node]['fitness'] += self.payoff_matrix[2][0]
            self.G.nodes[node]['fitness'] += self.payoff_matrix[2][1]
          else:
            self.G.nodes[node]['fitness'] += self.payoff_matrix[3][0]
            self.G.nodes[node]['fitness'] += self.payoff_matrix[3][1] 


      self.random_model.mark_influenced(self.j)
      self.calculate_propensity()
      self.t+=1
      self.random_model.t+=1
    self.calculate_normalized_propensity()
    return
  
  def calculate_probability_imitate(self, fitnessA, fitnessB):
    exponent = -self.beta * (fitnessB - fitnessA)
    return pow(1 + pow(math.e, exponent), -1)

  def calculate_propensity(self):
    super().calculate_propensity()

  def calculate_normalized_propensity(self):
    super().calculate_normalized_propensity()

  def neighbors_at_distance(self, source, neighbors_list):
    super().neighbors_at_distance(source, neighbors_list)

  def update_average_probabilities(self):
    super().update_average_probabilities()
  
  def create_random_model(self):
    self.random_model = RandomModel(self.Z, self.avg_degree, self.model_name)
  
  def colorMap(self, color_map):
    super().colorMap(color_map)

"""# Run

## run SIR
"""

#model = SIRModel(1000, 2, 'BA')
#model.simulate_SIR(0.5, 0.5)

model = SIRModel(1000, 5, 'BA')
model.simulate_SIR(0.9, 0.2)

model = SIRModel(1000, 4, 'HeSW')
model.simulate_SIR(0.9, 0.2)

model = SIRModel(1000, 7, 'HoSW')
model.simulate_SIR(1, 0.2)

model = SIRModel(1000, 2, 'Exp')
model.simulate_SIR(1, 0.2)

"""## run VM"""

model = VoterModel(1000, 6, 'HeSW')
model.simulate_VM()

model = VoterModel(1000, 2, 'BA')
model.simulate_VM()

model = VoterModel(100, 2, 'BA')
model.simulate_VM()

model = VoterModel(1000, 2, 'Exp')
model.simulate_VM()

model = VoterModel(1000, 20, 'HoSW')
model.simulate_VM()

"""## run PD"""

model = PDModel(1000, 2, 'BA')
model.simulate_PD(0.8)

model = PDModel(1000, 4, 'HeSW')
model.simulate_PD(0.2)

model = PDModel(100, 6, 'HoSW')
model.simulate_PD(0.8)

model = PDModel(500, 5, 'Exp')
model.simulate_PD(0.8)

"""# Notes 
j -> number of individuals carrying the trait in a population
Z -> population size
n -> distance 

δn(j/Z) -> propensity that 2 individuals at a distance n self-organize in the    same trait relative to a random distribution of traits

ϵn(j/Z) -> the average probability that a node shares the same trait with nodes located at a network distance n

ϵn_rand(j/Z) -> the same quantity associated with a random distribution of traits, given by j/Z

### Stochastic Weight Averaging
new average = average * t + w / t + 1
use for ϵn(j/Z)


"""